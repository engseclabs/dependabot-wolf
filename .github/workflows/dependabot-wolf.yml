name: Dependabot Wolf
on:
  schedule:
    - cron: '0 0 * * *'  # Daily at midnight
  workflow_dispatch:

jobs:
  call-copilot:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.DEPENDABOT_PAT }}
          script: |
            // Get all Dependabot alerts
            const alerts = await github.rest.dependabot.listAlertsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            // Get all open PRs
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            // Find stuck alerts (alerts without Dependabot PRs)
            const stuckAlerts = alerts.data.filter(alert => {
              const pkg = alert.dependency.package.name;
              return !prs.data.some(pr =>
                pr.user.login === 'dependabot[bot]' && pr.title.includes(pkg)
              );
            });

            if (stuckAlerts.length === 0) {
              console.log('No stuck alerts');
              return;
            }

            console.log(`Found ${stuckAlerts.length} stuck alerts`);

            // For each stuck alert, create an issue if one doesn't exist
            for (const alert of stuckAlerts) {
              const cve = alert.security_advisory.cve_id || alert.security_advisory.ghsa_id;
              const pkg = alert.dependency.package.name;

              // Check if issue already exists
              const existing = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'dependabot-wolf'
              });

              if (existing.data.some(issue => issue.title.includes(cve))) {
                console.log(`Issue already exists for ${cve}`);
                continue;
              }

              // Build issue body with only what Copilot needs to fix
              const vuln = alert.security_vulnerability;
              const dep = alert.dependency;

              const patchedVersion = vuln.first_patched_version?.identifier || 'latest';
              const isTransitive = dep.relationship === 'transitive';

              let issueBody;
              if (isTransitive) {
                // For transitive deps, Copilot needs to know which direct dependency to update
                issueBody = `Fix ${cve} by updating \`${pkg}\` to version ${patchedVersion} or higher.\n\n` +
                  `This is a transitive dependency in \`${dep.manifest_path}\`. ` +
                  `You'll need to update the parent dependency that brings it in.\n\n` +
                  `Alert: ${alert.html_url}`;
              } else {
                // For direct deps, just tell Copilot what version to update to
                issueBody = `Update \`${pkg}\` to version ${patchedVersion} or higher to fix ${cve}.\n\n` +
                  `Manifest: \`${dep.manifest_path}\`\n\n` +
                  `Alert: ${alert.html_url}`;
              }

              // Create issue
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Fix ${cve}: ${pkg}`,
                labels: ['dependabot-wolf'],
                body: issueBody
              });

              console.log(`Created issue #${issue.data.number} for ${cve}`);

              // Assign to Copilot (this is how you invoke it)
              try {
                await github.rest.issues.addAssignees({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.data.number,
                  assignees: ['copilot']
                });
                console.log(`Assigned issue #${issue.data.number} to Copilot`);
              } catch (error) {
                console.log(`Could not assign to Copilot: ${error.message}`);
              }
            }
