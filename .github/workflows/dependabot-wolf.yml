name: Dependabot Wolf
on:
  schedule:
    - cron: '0 0 * * *'  # Daily
  workflow_dispatch:     # Manual trigger

jobs:
  fix-stuck-alerts:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      security-events: read
    steps:
      - uses: actions/checkout@v4

      - name: Find stuck Dependabot alerts
        id: find-alerts
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.DEPENDABOT_PAT }}
          script: |
            // Get all open Dependabot alerts
            const alerts = await github.rest.dependabot.listAlertsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            console.log(`Found ${alerts.data.length} open Dependabot alerts`);

            // Filter: no associated PR = stuck
            const stuck = [];
            for (const alert of alerts.data) {
              console.log(`Checking alert ${alert.number}: ${alert.security_advisory.cve_id || alert.security_advisory.ghsa_id}`);

              // Check if Dependabot created a PR for this
              const packageName = alert.dependency.package.name;
              const ecosystem = alert.dependency.package.ecosystem;

              // Try to find OPEN PRs created by dependabot for this dependency
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              // Check if any OPEN PR is for this dependency
              const hasOpenPR = prs.data.some(pr => {
                return pr.user.login === 'dependabot[bot]' &&
                       pr.title.includes(packageName);
              });

              if (!hasOpenPR) {
                console.log(`  -> Stuck! No open PR found for ${packageName}`);
                stuck.push(alert);
              } else {
                console.log(`  -> Has open PR, skipping`);
              }
            }

            console.log(`Found ${stuck.length} stuck alerts`);
            return stuck;

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create fix PR for each stuck alert
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.DEPENDABOT_PAT }}
          script: |
            const stuck = ${{ steps.find-alerts.outputs.result }};
            const fs = require('fs');
            const { execSync } = require('child_process');

            console.log(`Processing ${stuck.length} stuck alerts`);

            for (const alert of stuck) {
              const cveId = alert.security_advisory.cve_id || alert.security_advisory.ghsa_id;
              const packageName = alert.dependency.package.name;
              const isTransitive = alert.dependency.relationship === 'transitive';

              // Create branch name
              const branch = `wolf/fix-${cveId}-${packageName}`.replace(/[^a-zA-Z0-9-]/g, '-');

              console.log(`Creating branch ${branch} for ${cveId} (transitive: ${isTransitive})`);

              try {
                // Get default branch ref
                const { data: ref } = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'heads/main'
                });

                // Check if branch already exists
                try {
                  await github.rest.git.getRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${branch}`
                  });
                  console.log(`Branch ${branch} already exists, skipping`);
                  continue;
                } catch (e) {
                  // Branch doesn't exist, continue
                }

                // Create new branch and check it out
                execSync(`git checkout -b ${branch}`, { stdio: 'inherit' });

                // Get vulnerability details
                const vulnerability = alert.security_advisory.vulnerabilities[0];
                const patchedVersions = vulnerability?.first_patched_version?.identifier || 'See advisory';

                let fixApplied = false;
                let fixDescription = '';

                // Attempt to fix based on dependency type
                if (isTransitive) {
                  console.log(`Attempting transitive dependency fix for ${packageName}`);

                  // Read package.json
                  const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));

                  // Check if package is locked via overrides
                  if (packageJson.overrides && packageJson.overrides[packageName]) {
                    console.log(`Found override locking ${packageName} to ${packageJson.overrides[packageName]}`);

                    // Remove the override
                    delete packageJson.overrides[packageName];

                    // Remove overrides section if empty
                    if (Object.keys(packageJson.overrides).length === 0) {
                      delete packageJson.overrides;
                    }

                    fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2) + '\n');
                    execSync('git add package.json', { stdio: 'inherit' });
                    execSync(`git commit -m "Remove ${packageName} override to allow security update"`, { stdio: 'inherit' });

                    fixDescription = `Removed \`overrides.${packageName}\` from package.json to allow npm to resolve the patched version ${patchedVersions}`;
                    fixApplied = true;
                  }

                  // Regenerate package-lock.json
                  console.log('Running npm install to update dependencies...');
                  execSync('npm install', { stdio: 'inherit' });
                  execSync('git add package-lock.json', { stdio: 'inherit' });
                  execSync(`git commit -m "Update package-lock.json with patched ${packageName}"`, { stdio: 'inherit' });

                  fixDescription += `\n\nRan \`npm install\` to update package-lock.json with patched ${packageName} version.`;
                } else {
                  console.log(`Attempting direct dependency update for ${packageName}`);

                  // Try direct update
                  try {
                    execSync(`npm install ${packageName}@latest`, { stdio: 'inherit' });
                    execSync('git add package.json package-lock.json', { stdio: 'inherit' });
                    execSync(`git commit -m "Update ${packageName} to fix ${cveId}"`, { stdio: 'inherit' });

                    fixDescription = `Updated ${packageName} to latest version to fix vulnerability.`;
                    fixApplied = true;
                  } catch (installError) {
                    console.error(`Failed to update ${packageName} directly: ${installError.message}`);
                    fixDescription = `Could not automatically update ${packageName}. Manual intervention required.`;
                  }
                }

                // Push branch
                execSync(`git push origin ${branch}`, { stdio: 'inherit' });

                // Create PR
                const pr = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `Fix ${cveId}: Update ${packageName}`,
                  head: branch,
                  base: 'main',
                  draft: true,
                  body: `## ðŸ¤– Dependabot Wolf - Automated Fix Attempt\n\n` +
                        `**CVE:** ${cveId}\n` +
                        `**Severity:** ${alert.security_advisory.severity}\n` +
                        `**Package:** ${packageName}\n` +
                        `**Dependency Type:** ${isTransitive ? 'Transitive' : 'Direct'}\n` +
                        `**Patched Version:** ${patchedVersions}\n` +
                        `**Advisory URL:** ${alert.security_advisory.html_url}\n\n` +
                        `### What Changed\n\n` +
                        `${fixDescription}\n\n` +
                        `### Testing Required\n\n` +
                        `- [ ] Run tests to ensure no breaking changes\n` +
                        `- [ ] Verify the vulnerability is resolved\n` +
                        `- [ ] Review dependency tree with \`npm ls ${packageName}\`\n\n` +
                        `### For Review\n\n` +
                        `${isTransitive ?
                          `This is a **transitive dependency** vulnerability. The fix involves updating parent dependencies or removing version locks to allow npm to resolve the patched version.\n\n` :
                          `This is a **direct dependency** vulnerability. The fix attempts to update to the latest version.\n\n`}` +
                        `@github-copilot workspace Please review this fix and suggest any additional changes needed.`
                });

                console.log(`âœ“ Created PR #${pr.data.number} for ${cveId}`);

                // Switch back to main
                execSync('git checkout main', { stdio: 'inherit' });
              } catch (error) {
                console.error(`âœ— Failed to create PR for ${cveId}: ${error.message}`);
                // Try to switch back to main even if there's an error
                try {
                  execSync('git checkout main', { stdio: 'inherit' });
                } catch (e) {
                  console.error('Failed to switch back to main branch');
                }
              }
            }
