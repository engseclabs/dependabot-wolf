name: Dependabot Wolf
on:
  schedule:
    - cron: '0 0 * * *'  # Daily
  workflow_dispatch:     # Manual trigger

jobs:
  fix-stuck-alerts:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      security-events: read
    steps:
      - uses: actions/checkout@v4

      - name: Find stuck Dependabot alerts
        id: find-alerts
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.DEPENDABOT_PAT }}
          script: |
            // Get all open Dependabot alerts
            const alerts = await github.rest.dependabot.listAlertsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            console.log(`Found ${alerts.data.length} open Dependabot alerts`);

            // Filter: no associated PR = stuck
            const stuck = [];
            for (const alert of alerts.data) {
              console.log(`Checking alert ${alert.number}: ${alert.security_advisory.cve_id || alert.security_advisory.ghsa_id}`);

              // Check if Dependabot created a PR for this
              const packageName = alert.dependency.package.name;
              const ecosystem = alert.dependency.package.ecosystem;

              // Try to find OPEN PRs created by dependabot for this dependency
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              // Check if any OPEN PR is for this dependency
              const hasOpenPR = prs.data.some(pr => {
                return pr.user.login === 'dependabot[bot]' &&
                       pr.title.includes(packageName);
              });

              if (!hasOpenPR) {
                console.log(`  -> Stuck! No open PR found for ${packageName}`);
                stuck.push(alert);
              } else {
                console.log(`  -> Has open PR, skipping`);
              }
            }

            console.log(`Found ${stuck.length} stuck alerts`);
            return stuck;

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Configure git
        run: |
          git config --global user.name "dependabot-wolf[bot]"
          git config --global user.email "dependabot-wolf[bot]@users.noreply.github.com"

      - name: Create fix PR for each stuck alert
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.DEPENDABOT_PAT }}
          script: |
            const stuck = ${{ steps.find-alerts.outputs.result }};
            const fs = require('fs');
            const { execSync } = require('child_process');

            console.log(`Processing ${stuck.length} stuck alerts`);

            for (const alert of stuck) {
              const cveId = alert.security_advisory.cve_id || alert.security_advisory.ghsa_id;
              const packageName = alert.dependency.package.name;
              const isTransitive = alert.dependency.relationship === 'transitive';

              // Create branch name
              const branch = `wolf/fix-${cveId}-${packageName}`.replace(/[^a-zA-Z0-9-]/g, '-');

              console.log(`Creating branch ${branch} for ${cveId} (transitive: ${isTransitive})`);

              try {
                // Get default branch ref
                const { data: ref } = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'heads/main'
                });

                // Check if branch already exists
                try {
                  await github.rest.git.getRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${branch}`
                  });
                  console.log(`Branch ${branch} already exists, skipping`);
                  continue;
                } catch (e) {
                  // Branch doesn't exist, continue
                }

                // Create new branch and check it out
                execSync(`git checkout -b ${branch}`, { stdio: 'inherit' });

                // Get vulnerability details
                const vulnerability = alert.security_advisory.vulnerabilities[0];
                const patchedVersions = vulnerability?.first_patched_version?.identifier || 'See advisory';

                let fixApplied = false;
                let fixDescription = '';

                // Attempt to fix based on dependency type
                if (isTransitive) {
                  console.log(`Attempting transitive dependency fix for ${packageName}`);

                  // Read package.json and package-lock.json
                  const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                  const packageLock = JSON.parse(fs.readFileSync('package-lock.json', 'utf8'));

                  // Find parent package that depends on the vulnerable transitive dependency
                  let parentPackage = null;
                  let parentVersion = null;

                  // Check all dependencies in package.json
                  const allDeps = {
                    ...packageJson.dependencies,
                    ...packageJson.devDependencies,
                    ...packageJson.peerDependencies,
                    ...packageJson.optionalDependencies
                  };

                  // Look through package-lock to find which direct dependency brings in the vulnerable package
                  for (const [depName, depVersion] of Object.entries(allDeps)) {
                    const lockEntry = packageLock.packages?.[`node_modules/${depName}`];
                    if (lockEntry?.dependencies?.[packageName]) {
                      console.log(`Found ${depName}@${depVersion} depends on ${packageName}`);
                      parentPackage = depName;
                      parentVersion = depVersion;
                      break;
                    }
                  }

                  if (parentPackage) {
                    console.log(`Attempting to update parent dependency ${parentPackage} to get patched ${packageName}`);

                    // Remove override if it exists and write to disk BEFORE npm install
                    let removedOverride = false;
                    if (packageJson.overrides && packageJson.overrides[packageName]) {
                      console.log(`Removing override locking ${packageName} to ${packageJson.overrides[packageName]}`);
                      delete packageJson.overrides[packageName];
                      if (Object.keys(packageJson.overrides).length === 0) {
                        delete packageJson.overrides;
                      }
                      removedOverride = true;

                      // Write package.json to disk BEFORE running npm install
                      fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2) + '\n');
                      console.log('Wrote package.json without override to disk');
                    }

                    // Try to update parent package to latest
                    try {
                      console.log(`Running: npm install ${parentPackage}@latest`);
                      execSync(`npm install ${parentPackage}@latest`, { stdio: 'inherit' });

                      // Get the new version
                      const updatedPackageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                      const newParentVersion = updatedPackageJson.dependencies?.[parentPackage] ||
                                             updatedPackageJson.devDependencies?.[parentPackage];

                      fixDescription = `Updated \`${parentPackage}\` from \`${parentVersion}\` to \`${newParentVersion}\` to resolve transitive \`${packageName}\` vulnerability.`;

                      if (removedOverride) {
                        fixDescription += `\n\nRemoved \`overrides.${packageName}\` to allow npm to resolve the patched version.`;
                      }

                      execSync('git add package.json package-lock.json', { stdio: 'inherit' });
                      execSync(`git commit -m "Update ${parentPackage} to fix ${packageName} vulnerability (${cveId})"`, { stdio: 'inherit' });

                      fixApplied = true;
                    } catch (updateError) {
                      console.error(`Failed to update ${parentPackage}: ${updateError.message}`);

                      // Fallback: just remove override and regenerate lock file
                      if (removedOverride) {
                        fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2) + '\n');
                        execSync('rm -f package-lock.json', { stdio: 'inherit' });
                        execSync('npm install', { stdio: 'inherit' });
                        execSync('git add package.json package-lock.json', { stdio: 'inherit' });
                        execSync(`git commit -m "Remove ${packageName} override and regenerate lock file"`, { stdio: 'inherit' });

                        fixDescription = `Removed \`overrides.${packageName}\` and regenerated package-lock.json. Could not automatically update ${parentPackage}.`;
                      } else {
                        fixDescription = `Could not automatically fix transitive dependency. Manual update of ${parentPackage} required.`;
                      }
                    }
                  } else {
                    console.log(`Could not identify parent dependency for ${packageName}`);
                    fixDescription = `Could not automatically identify which dependency to update for transitive ${packageName} vulnerability.`;
                  }
                } else {
                  console.log(`Attempting direct dependency update for ${packageName}`);

                  // Try direct update
                  try {
                    execSync(`npm install ${packageName}@latest`, { stdio: 'inherit' });
                    execSync('git add package.json package-lock.json', { stdio: 'inherit' });
                    execSync(`git commit -m "Update ${packageName} to fix ${cveId}"`, { stdio: 'inherit' });

                    fixDescription = `Updated ${packageName} to latest version to fix vulnerability.`;
                    fixApplied = true;
                  } catch (installError) {
                    console.error(`Failed to update ${packageName} directly: ${installError.message}`);
                    fixDescription = `Could not automatically update ${packageName}. Manual intervention required.`;
                  }
                }

                // Push branch
                execSync(`git push origin ${branch}`, { stdio: 'inherit' });

                // Create PR
                const pr = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `Fix ${cveId}: Update ${packageName}`,
                  head: branch,
                  base: 'main',
                  draft: true,
                  body: `## ðŸ¤– Dependabot Wolf - Automated Fix Attempt\n\n` +
                        `**CVE:** ${cveId}\n` +
                        `**Severity:** ${alert.security_advisory.severity}\n` +
                        `**Package:** ${packageName}\n` +
                        `**Dependency Type:** ${isTransitive ? 'Transitive' : 'Direct'}\n` +
                        `**Patched Version:** ${patchedVersions}\n` +
                        `**Advisory URL:** ${alert.security_advisory.html_url}\n\n` +
                        `### What Changed\n\n` +
                        `${fixDescription}\n\n` +
                        `### Testing Required\n\n` +
                        `- [ ] Run tests to ensure no breaking changes\n` +
                        `- [ ] Verify the vulnerability is resolved\n` +
                        `- [ ] Review dependency tree with \`npm ls ${packageName}\`\n\n` +
                        `### For Review\n\n` +
                        `${isTransitive ?
                          `This is a **transitive dependency** vulnerability. The fix involves updating parent dependencies or removing version locks to allow npm to resolve the patched version.\n\n` :
                          `This is a **direct dependency** vulnerability. The fix attempts to update to the latest version.\n\n`}` +
                        `@github-copilot workspace Please review this fix and suggest any additional changes needed.`
                });

                console.log(`âœ“ Created PR #${pr.data.number} for ${cveId}`);

                // Switch back to main
                execSync('git checkout main', { stdio: 'inherit' });
              } catch (error) {
                console.error(`âœ— Failed to create PR for ${cveId}: ${error.message}`);
                // Try to switch back to main even if there's an error
                try {
                  execSync('git checkout main', { stdio: 'inherit' });
                } catch (e) {
                  console.error('Failed to switch back to main branch');
                }
              }
            }
