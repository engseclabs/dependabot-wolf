name: Dependabot Wolf
on:
  schedule:
    - cron: '0 0 * * *'  # Daily
  workflow_dispatch:     # Manual trigger

jobs:
  fix-transitive-dependencies:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      security-events: read
    steps:
      - uses: actions/checkout@v4

      - name: Find transitive dependency alerts
        id: find-alerts
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.DEPENDABOT_PAT }}
          script: |
            // Get all open Dependabot alerts
            const alerts = await github.rest.dependabot.listAlertsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            console.log(`Found ${alerts.data.length} open Dependabot alerts`);

            // Filter for transitive dependency alerts without open PRs
            // These are alerts where Dependabot says "cannot create a PR" because:
            // - Fix requires updating parent dependency
            // - Update is outside allowed range, major/breaking, or ambiguous
            const transitiveAlerts = [];
            for (const alert of alerts.data) {
              const cveId = alert.security_advisory.cve_id || alert.security_advisory.ghsa_id;
              const packageName = alert.dependency.package.name;
              const isTransitive = alert.dependency.relationship === 'transitive';

              console.log(`Checking alert ${alert.number} (${cveId}): ${packageName} - ${isTransitive ? 'transitive' : 'direct'}`);

              // Skip non-transitive dependencies (Dependabot can handle these)
              if (!isTransitive) {
                console.log(`  -> Skipping: not a transitive dependency`);
                continue;
              }

              // Check if Dependabot created a PR for this
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              const hasOpenPR = prs.data.some(pr => {
                return pr.user.login === 'dependabot[bot]' &&
                       pr.title.includes(packageName);
              });

              if (!hasOpenPR) {
                console.log(`  -> Found transitive alert where Dependabot cannot create PR: ${packageName}`);
                transitiveAlerts.push(alert);
              } else {
                console.log(`  -> Has open PR, skipping`);
              }
            }

            console.log(`Found ${transitiveAlerts.length} transitive alerts where Dependabot cannot create PRs`);
            return transitiveAlerts;

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Configure git
        run: |
          git config --global user.name "dependabot-wolf[bot]"
          git config --global user.email "dependabot-wolf[bot]@users.noreply.github.com"

      - name: Fix transitive dependency vulnerabilities
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.DEPENDABOT_PAT }}
          script: |
            const transitiveAlerts = ${{ steps.find-alerts.outputs.result }};
            const fs = require('fs');
            const { execSync } = require('child_process');

            console.log(`Processing ${transitiveAlerts.length} transitive dependency alerts`);

            for (const alert of transitiveAlerts) {
              const cveId = alert.security_advisory.cve_id || alert.security_advisory.ghsa_id;
              const packageName = alert.dependency.package.name;

              // Create branch name
              const branch = `wolf/fix-${cveId}-${packageName}`.replace(/[^a-zA-Z0-9-]/g, '-');

              console.log(`Creating branch ${branch} for transitive dependency ${packageName} (${cveId})`);

              try {
                // Get default branch ref
                const { data: ref } = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'heads/main'
                });

                // Check if branch already exists
                try {
                  await github.rest.git.getRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${branch}`
                  });
                  console.log(`Branch ${branch} already exists, skipping`);
                  continue;
                } catch (e) {
                  // Branch doesn't exist, continue
                }

                // Create new branch and check it out
                execSync(`git checkout -b ${branch}`, { stdio: 'inherit' });

                // Get vulnerability details
                const vulnerability = alert.security_advisory.vulnerabilities[0];
                const patchedVersions = vulnerability?.first_patched_version?.identifier || 'See advisory';

                let fixDescription = '';

                // Read package.json and package-lock.json
                const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                const packageLock = JSON.parse(fs.readFileSync('package-lock.json', 'utf8'));

                // Find parent package that depends on the vulnerable transitive dependency
                let parentPackage = null;
                let parentVersion = null;

                // Check all dependencies in package.json
                const allDeps = {
                  ...packageJson.dependencies,
                  ...packageJson.devDependencies,
                  ...packageJson.peerDependencies,
                  ...packageJson.optionalDependencies
                };

                // Look through package-lock to find which direct dependency brings in the vulnerable package
                for (const [depName, depVersion] of Object.entries(allDeps)) {
                  const lockEntry = packageLock.packages?.[`node_modules/${depName}`];
                  if (lockEntry?.dependencies?.[packageName]) {
                    console.log(`Found parent dependency: ${depName}@${depVersion} ‚Üí ${packageName}`);
                    parentPackage = depName;
                    parentVersion = depVersion;
                    break;
                  }
                }

                if (parentPackage) {
                  console.log(`Updating parent dependency ${parentPackage} to fix transitive ${packageName} vulnerability`);

                  // Remove override if it exists and write to disk BEFORE npm install
                  let removedOverride = false;
                  if (packageJson.overrides && packageJson.overrides[packageName]) {
                    console.log(`Removing override locking ${packageName} to ${packageJson.overrides[packageName]}`);
                    delete packageJson.overrides[packageName];
                    if (Object.keys(packageJson.overrides).length === 0) {
                      delete packageJson.overrides;
                    }
                    removedOverride = true;

                    // Write package.json to disk BEFORE running npm install
                    fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2) + '\n');
                    console.log('Wrote package.json without override to disk');
                  }

                  // Try to update parent package to latest
                  try {
                    console.log(`Running: npm install ${parentPackage}@latest`);
                    execSync(`npm install ${parentPackage}@latest`, { stdio: 'inherit' });

                    // Get the new version
                    const updatedPackageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                    const newParentVersion = updatedPackageJson.dependencies?.[parentPackage] ||
                                           updatedPackageJson.devDependencies?.[parentPackage];

                    fixDescription = `Updated \`${parentPackage}\` from \`${parentVersion}\` to \`${newParentVersion}\` to resolve transitive \`${packageName}\` vulnerability.`;

                    if (removedOverride) {
                      fixDescription += `\n\nRemoved \`overrides.${packageName}\` to allow npm to resolve the patched version.`;
                    }

                    execSync('git add package.json package-lock.json', { stdio: 'inherit' });
                    execSync(`git commit -m "Update ${parentPackage} to fix ${packageName} vulnerability (${cveId})"`, { stdio: 'inherit' });
                  } catch (updateError) {
                    console.error(`Failed to update ${parentPackage}: ${updateError.message}`);

                    // Fallback: just remove override and regenerate lock file
                    if (removedOverride) {
                      fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2) + '\n');
                      execSync('rm -f package-lock.json', { stdio: 'inherit' });
                      execSync('npm install', { stdio: 'inherit' });
                      execSync('git add package.json package-lock.json', { stdio: 'inherit' });
                      execSync(`git commit -m "Remove ${packageName} override and regenerate lock file"`, { stdio: 'inherit' });

                      fixDescription = `Removed \`overrides.${packageName}\` and regenerated package-lock.json. Could not automatically update ${parentPackage}.`;
                    } else {
                      fixDescription = `Could not automatically fix transitive dependency. Manual update of ${parentPackage} required.`;
                    }
                  }
                } else {
                  console.log(`Could not identify parent dependency for ${packageName}`);
                  fixDescription = `Could not automatically identify which dependency to update for transitive ${packageName} vulnerability.`;
                }

                // Push branch
                execSync(`git push origin ${branch}`, { stdio: 'inherit' });

                // Create PR
                const pr = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `Fix ${cveId}: Update ${packageName}`,
                  head: branch,
                  base: 'main',
                  draft: true,
                  body: `## üê∫ Dependabot Wolf - Transitive Dependency Fix\n\n` +
                        `**CVE:** ${cveId}\n` +
                        `**Severity:** ${alert.security_advisory.severity}\n` +
                        `**Vulnerable Package:** ${packageName} (transitive dependency)\n` +
                        `**Patched Version:** ${patchedVersions}\n` +
                        `**Advisory:** ${alert.security_advisory.html_url}\n\n` +
                        `### What Changed\n\n` +
                        `${fixDescription}\n\n` +
                        `### Why Wolf Created This PR\n\n` +
                        `This vulnerability is in a **transitive dependency** (not directly in your \`package.json\`). ` +
                        `Dependabot raised an alert but explicitly said it "cannot create a PR" because the fix requires ` +
                        `updating a parent dependency‚Äîlikely a major/breaking version upgrade. ` +
                        `Wolf identified the parent package and created this fix for you to review.\n\n` +
                        `### Testing Required\n\n` +
                        `- [ ] Run your test suite to ensure no breaking changes\n` +
                        `- [ ] Verify the vulnerability is resolved with \`npm audit\`\n` +
                        `- [ ] Review dependency tree with \`npm ls ${packageName}\`\n\n` +
                        `@github-copilot workspace Please review this fix and suggest any additional changes needed.`
                });

                console.log(`‚úì Created PR #${pr.data.number} for ${cveId}`);

                // Switch back to main
                execSync('git checkout main', { stdio: 'inherit' });
              } catch (error) {
                console.error(`‚úó Failed to create PR for ${cveId}: ${error.message}`);
                // Try to switch back to main even if there's an error
                try {
                  execSync('git checkout main', { stdio: 'inherit' });
                } catch (e) {
                  console.error('Failed to switch back to main branch');
                }
              }
            }
